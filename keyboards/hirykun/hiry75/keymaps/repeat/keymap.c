#include QMK_KEYBOARD_H

#define WAITING_TIME_HOLD 10
#define WAITING_TIME_SWITCH 25
#define REPEAT_KEY_NUM 22

enum my_keycodes {
	RPTH_1 = SAFE_RANGE,
	RPTH_2,
	RPTH_3,
	RPTH_4,
	RPTH_5,
	RPTH_Q,
	RPTH_E,
	RPTH_R,
	RPTH_F,
	RPTH_F1,
	RPTH_F2,
	RPTS_1,
	RPTS_2,
	RPTS_3,
	RPTS_4,
	RPTS_5,
	RPTS_Q,
	RPTS_E,
	RPTS_R,
	RPTS_F,
	RPTS_F1,
	RPTS_F2
};
bool repeat_state[REPEAT_KEY_NUM] = {0};
uint16_t repeat_timer[REPEAT_KEY_NUM] = {0};
uint16_t first_key_hold = RPTH_1;
uint16_t last_key_hold = RPTH_F2;
uint16_t first_key_switch = RPTS_1;
uint16_t last_key_switch = RPTS_F2;

static const char PROGMEM black[512] = {0};
static const char PROGMEM hold_logo[] = {
	// '未标题-1', 32x10px
	0x00, 0x78, 0xfc, 0xfe, 0xff, 0x01, 0xef, 0xef, 0xef, 0x01, 0xff, 0x83, 0x7d, 0x7d, 0x7d, 0x83,
	0xff, 0x01, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0x01, 0x7d, 0x7d, 0x7d, 0x83, 0xfe, 0xfc, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00
};
static const char PROGMEM hold_logo_reverse[] = {
	// '未标题-1反', 32x10px
	0x00, 0x78, 0x84, 0x02, 0x01, 0xff, 0x11, 0x11, 0x11, 0xff, 0x01, 0x7d, 0x83, 0x83, 0x83, 0x7d,
	0x01, 0xff, 0x81, 0x81, 0x81, 0x81, 0x01, 0xff, 0x83, 0x83, 0x83, 0x7d, 0x02, 0x84, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00
};
static const char PROGMEM switch_logo[] = {
	// '未标题-2', 32x10px
	0x00, 0x78, 0xfc, 0xfe, 0xff, 0xb3, 0x6d, 0x6d, 0x6d, 0x9b, 0xff, 0x81, 0x7f, 0x8f, 0x7f, 0x81,
	0xff, 0xff, 0x7d, 0x01, 0x7d, 0xff, 0xff, 0xf9, 0xfd, 0x01, 0xfd, 0xf9, 0xfe, 0xfc, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00
};
static const char PROGMEM switch_logo_reverse[] = {
	// '未标题-2反', 32x10px
	0x00, 0x78, 0x84, 0x02, 0x01, 0x4d, 0x93, 0x93, 0x93, 0x65, 0x01, 0x7f, 0x81, 0x71, 0x81, 0x7f,
	0x01, 0x01, 0x83, 0xff, 0x83, 0x01, 0x01, 0x07, 0x03, 0xff, 0x03, 0x07, 0x02, 0x84, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00
};
static const char PROGMEM caps_logo[] = {
	// '未标题-3', 32x24px
	0x00, 0x78, 0xfc, 0xfe, 0xff, 0x83, 0x7d, 0x7d, 0x7d, 0xbb, 0xff, 0x07, 0xdb, 0xdd, 0xdb, 0x07,
	0xff, 0x01, 0xed, 0xed, 0xed, 0xf3, 0xff, 0xb3, 0x6d, 0x6d, 0x6d, 0x9b, 0xfe, 0xfc, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x03, 0x23, 0x43, 0x83, 0x03, 0x03, 0x03, 0x03, 0x03, 0xe3, 0x13, 0x13,
	0x13, 0x13, 0xe3, 0x03, 0x03, 0x03, 0x03, 0x03, 0x83, 0x43, 0x23, 0x03, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x7e, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x7e, 0x00, 0x00, 0x00, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const char PROGMEM caps_logo_reverse[] = {
	// '未标题-3反', 32x24px
	0x00, 0x78, 0x84, 0x02, 0x01, 0x7d, 0x83, 0x83, 0x83, 0x45, 0x01, 0xf9, 0x25, 0x23, 0x25, 0xf9,
	0x01, 0xff, 0x13, 0x13, 0x13, 0x0d, 0x01, 0x4d, 0x93, 0x93, 0x93, 0x65, 0x02, 0x84, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x32, 0x0a, 0x0a,
	0x0a, 0x0a, 0xf2, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x81, 0x81, 0x81, 0x81,
	0x81, 0x81, 0x81, 0x81, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const char PROGMEM layer_0[] = {
	// 'layer_0', 32x32px
	0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x03, 0xf3, 0xf3, 0x03, 0x07, 0xff, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x11, 0x19, 0xfd, 0xfd, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x38, 0x30, 0x33, 0x33, 0x30, 0x38, 0x3f, 0x3f, 0x3f, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2c, 0x2c, 0x2f, 0x2f, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x85, 0xc5, 0x6d, 0x39, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x45, 0x45, 0xed, 0xb9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2e, 0x2f, 0x2d, 0x2c, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x26, 0x2c, 0x28, 0x28, 0x2c, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00
};
static const char PROGMEM layer_1[] = {
	// 'layer_1', 32x32px
	0x00, 0xfe, 0x01, 0x01, 0x01, 0xf9, 0xfd, 0x0d, 0x0d, 0xfd, 0xf9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0xff, 0xff, 0xff, 0xef, 0xe7, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x27, 0x2f, 0x2c, 0x2c, 0x2f, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x33, 0x33, 0x30, 0x30, 0x33, 0x33, 0x3f, 0x3f, 0x3f, 0x1f, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x85, 0xc5, 0x6d, 0x39, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x45, 0x45, 0xed, 0xb9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2e, 0x2f, 0x2d, 0x2c, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x26, 0x2c, 0x28, 0x28, 0x2c, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00
};
static const char PROGMEM layer_2[] = {
	// 'layer_2', 32x32px
	0x00, 0xfe, 0x01, 0x01, 0x01, 0xf9, 0xfd, 0x0d, 0x0d, 0xfd, 0xf9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x11, 0x19, 0xfd, 0xfd, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x27, 0x2f, 0x2c, 0x2c, 0x2f, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2c, 0x2c, 0x2f, 0x2f, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0xfe, 0xff, 0xff, 0xff, 0xe7, 0xf3, 0x7b, 0x3b, 0x93, 0xc7, 0xff, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x45, 0x45, 0xed, 0xb9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x31, 0x30, 0x32, 0x33, 0x33, 0x33, 0x3f, 0x3f, 0x3f, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x26, 0x2c, 0x28, 0x28, 0x2c, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00
};
static const char PROGMEM layer_3[] = {
	// 'layer_2', 32x32px
	0x00, 0xfe, 0x01, 0x01, 0x01, 0xf9, 0xfd, 0x0d, 0x0d, 0xfd, 0xf9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x11, 0x19, 0xfd, 0xfd, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x27, 0x2f, 0x2c, 0x2c, 0x2f, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2c, 0x2c, 0x2f, 0x2f, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0xfe, 0xff, 0xff, 0xff, 0xe7, 0xf3, 0x7b, 0x3b, 0x93, 0xc7, 0xff, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x45, 0x45, 0xed, 0xb9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x31, 0x30, 0x32, 0x33, 0x33, 0x33, 0x3f, 0x3f, 0x3f, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x26, 0x2c, 0x28, 0x28, 0x2c, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00
};
static const char PROGMEM layer_default[] = {
	// 'layer_default', 32x32px
	0x00, 0xfe, 0x01, 0x01, 0x01, 0xf9, 0xfd, 0x0d, 0x0d, 0xfd, 0xf9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x11, 0x19, 0xfd, 0xfd, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x27, 0x2f, 0x2c, 0x2c, 0x2f, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2c, 0x2c, 0x2f, 0x2f, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x85, 0xc5, 0x6d, 0x39, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0xfe, 0x01, 0x01, 0x01, 0x19, 0x0d, 0x45, 0x45, 0xed, 0xb9, 0x01, 0x01, 0x01, 0xfe, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x2e, 0x2f, 0x2d, 0x2c, 0x2c, 0x2c, 0x20, 0x20, 0x20, 0x1f, 0x00, 
	0x00, 0x1f, 0x20, 0x20, 0x20, 0x26, 0x2c, 0x28, 0x28, 0x2c, 0x27, 0x20, 0x20, 0x20, 0x1f, 0x00
};
static const char PROGMEM hiry75_logo[] = {
	// 'hiry75', 32x16px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00, 0x00, 0x41, 0x7f, 0x41, 0x00,
	0x00, 0x7f, 0x09, 0x19, 0x29, 0x46, 0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x41, 0x21, 0x11, 0x09, 0x07,
	0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00
};

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
	if(keycode >= first_key_hold && keycode <= last_key_hold) {
		if (record->event.pressed) {
			repeat_state[keycode - first_key_hold] = 1;
			repeat_timer[keycode - first_key_hold] = 0;
		}
		else {
			repeat_state[keycode - first_key_hold] = 0;
		}
		return false;
	}
	else if(keycode >= first_key_switch && keycode <= last_key_switch) {
		if (record->event.pressed) {
			repeat_state[keycode - first_key_hold] ^= 1;
			repeat_timer[keycode - first_key_hold] = 0;
		}
		return false;
	}
	else return true;
}

void matrix_scan_user(void) {
	for(uint8_t i = 0; i < REPEAT_KEY_NUM; ++i) {
		if(repeat_state[i]) {
			uint16_t current_keycode = i + first_key_hold;
			if(current_keycode <= last_key_hold && timer_elapsed(repeat_timer[i]) >= WAITING_TIME_HOLD) {
				switch (current_keycode)
				{
				case RPTH_1:
					tap_code(KC_1);
					break;
				case RPTH_2:
					tap_code(KC_2);
					break;
				case RPTH_3:
					tap_code(KC_3);
					break;
				case RPTH_4:
					tap_code(KC_4);
					break;
				case RPTH_5:
					tap_code(KC_5);
					break;
				case RPTH_Q:
					tap_code(KC_Q);
					break;
				case RPTH_E:
					tap_code(KC_E);
					break;
				case RPTH_F:
					tap_code(KC_F);
					break;
				case RPTH_R:
					tap_code(KC_R);
					break;
				case RPTH_F1:
					tap_code(KC_F1);
					break;
				case RPTH_F2:
					tap_code(KC_F2);
					break;
				default:
					break;
				}
				repeat_timer[i] = timer_read();
			}
			else if(current_keycode >= first_key_switch && timer_elapsed(repeat_timer[i]) >= WAITING_TIME_SWITCH) {
				switch (current_keycode)
				{
				case RPTS_1:
					tap_code(KC_1);
					break;
				case RPTS_2:
					tap_code(KC_2);
					break;
				case RPTS_3:
					tap_code(KC_3);
					break;
				case RPTS_4:
					tap_code(KC_4);
					break;
				case RPTS_5:
					tap_code(KC_5);
					break;
				case RPTS_Q:
					tap_code(KC_Q);
					break;
				case RPTS_E:
					tap_code(KC_E);
					break;
				case RPTS_F:
					tap_code(KC_F);
					break;
				case RPTS_R:
					tap_code(KC_R);
					break;
				case RPTS_F1:
					tap_code(KC_F1);
					break;
				case RPTS_F2:
					tap_code(KC_F2);
					break;
				default:
					break;
				}
				repeat_timer[i] = timer_read();
			}
		}
	}
}

/*按键映射*/
/*关于keymap和层的解读，详见 https://docs.qmk.fm/#/feature_layers 和 https://docs.qmk.fm/#/keymap */
/*可用的键详见 https://docs.qmk.fm/#/keycodes */
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	/*默认层*/
    [0] = LAYOUT (
    KC_ESC ,          KC_F1  , KC_F2  , KC_F3  , KC_F4  , KC_F5  , KC_F6  , KC_F7  , KC_F8  , KC_F9  , KC_F10 , KC_F11 , KC_F12 ,
	KC_GRV , KC_1   , KC_2   , KC_3   , KC_4   , KC_5   , KC_6   , KC_7   , KC_8   , KC_9   , KC_0   , KC_MINS, KC_EQL , KC_BSPC,
	KC_TAB , KC_Q   , KC_W   , KC_E   , KC_R   , KC_T   , KC_Y   , KC_U   , KC_I   , KC_O   , KC_P   , KC_LBRC, KC_RBRC, KC_BSLS,
	KC_CAPS, KC_A   , KC_S   , KC_D   , KC_F   , KC_G   , KC_H   , KC_J   , KC_K   , KC_L   , KC_SCLN, KC_QUOT, KC_ENT , KC_PSCR,
	KC_LSFT, KC_Z   , KC_X   , KC_C   , KC_V   , KC_B   , KC_N   , KC_M   , KC_COMM, KC_DOT , KC_SLSH, KC_RSFT, KC_UP  , KC_DEL ,
	KC_LCTL, KC_LWIN, KC_LALT,                   KC_SPC ,                            MO(1)  , MO(2)  , KC_LEFT, KC_DOWN, KC_RGHT	//MO()所指层的相同位置，需要写KC_TRNS，不能是XXXXXXX
    ),
	/*Fn层*/
    [1] = LAYOUT (
    _______,          RPTH_F1, RPTH_F2, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______,
	_______, RPTH_1 , RPTH_2 , RPTH_3 , RPTH_4 , RPTH_5 , _______, _______, _______, _______, _______, _______, _______, _______,
	_______, RPTH_Q , _______, RPTH_E , RPTH_R , _______, _______, _______, _______, _______, _______, _______, _______, _______,
	_______, _______, _______, _______, RPTH_F , _______, _______, _______, _______, _______, _______, _______, _______, _______,
	_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______,
	_______, _______, _______,                   _______,                            _______, _______, _______, _______, _______	//MO()所指层的相同位置，需要写KC_TRNS，不能是XXXXXXX
    ),
	[2] = LAYOUT (
	_______,          RPTS_F1, RPTS_F2, _______, _______, KC_VOLU, KC_VOLD, KC_MUTE, _______, CK_UP  , CK_DOWN, HF_DWLU, HF_DWLD,
	_______, RPTS_1 , RPTS_2 , RPTS_3 , RPTS_4 , RPTS_5 , _______, _______, _______, _______, _______, _______, QK_BOOT, MU_TOGG,
	_______, RPTS_Q , _______, RPTS_E , RPTS_R , _______, _______, _______, _______, _______, _______, _______, AU_NEXT, MU_NEXT,
	_______, _______, _______, _______, RPTS_F , _______, _______, _______, _______, _______, _______, _______, NK_TOGG, HF_TOGG,
	_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, RGB_MOD, RGB_VAI, AU_TOGG,
	_______, GU_TOGG, _______,                   RGB_TOG,                            _______, _______, RGB_HUI, RGB_SPI, RGB_SAI	//MO()所指层的相同位置，需要写KC_TRNS，不能是XXXXXXX
	)
};	//这里的分号一定不要忘记

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    return OLED_ROTATION_270;
}

bool oled_task_user(void) {
	bool hold_state = false, switch_state = false;
	for(uint8_t i = 0; i < REPEAT_KEY_NUM; ++i) {
		if(repeat_state[i]) {
			if(i <= last_key_hold - first_key_hold) {
				hold_state = true;
				i = last_key_hold - first_key_hold; 
			}
			if(i >= first_key_switch - first_key_hold) {
				switch_state = true;
				i = last_key_switch - first_key_hold;
			}
		}
	}
	if(hold_state) oled_write_raw_pic(hold_logo, 32, 10, 0, 1);
	else oled_write_raw_pic(hold_logo_reverse, 32, 10, 0, 1);
	if(switch_state) oled_write_raw_pic(switch_logo, 32 ,10, 0, 3);
	else oled_write_raw_pic(switch_logo_reverse, 32, 10, 0, 3);
	if(host_keyboard_led_state().caps_lock) oled_write_raw_pic(caps_logo, 32 ,24, 0, 5);
	else oled_write_raw_pic(caps_logo_reverse, 32, 24, 0, 5);
	switch (get_highest_layer(layer_state))
	{
	case 0:
		oled_write_raw_pic(layer_0, 32 ,32, 0, 9);
		break;
	case 1:
		oled_write_raw_pic(layer_1, 32 ,32, 0, 9);
		break;
	case 2:
		oled_write_raw_pic(layer_2, 32 ,32, 0, 9);
		break;
	case 3:
		oled_write_raw_pic(layer_3, 32 ,32, 0, 9);
		break;
	default:
		oled_write_raw_pic(layer_default, 32 ,32, 0, 9);
		break;
	}
	oled_write_raw_pic(hiry75_logo, 32 ,16, 0, 13);
    return false;
}

bool shutdown_user(bool jump_to_bootloader) {
	if(jump_to_bootloader) {
		oled_clear();
		oled_write(PSTR("BL\nMode"), false);
		rgb_matrix_set_color_all(RGB_OFF);
	}
	return false;
}
